const AcademicPlan = require("../models/StudentAcademicPlan");
const mongoose = require("mongoose");
const Course = require("../models/course");

async function hydrateCourseRefs(years) {
  const result = [];
  for (const y of years || []) {
    const newY = { ...y, semesters: [] };
    for (const s of y.semesters || []) {
      const newCourses = [];
      for (const c of s.courses || []) {
        if (c?.course) {
          newCourses.push(c);
          continue;
        }
        const code = c?.course_code || c?.code;
        if (!code) {
          newCourses.push(c); // leave as-is; validators will catch if needed
          continue;
        }
        const found = await Course.findOne(
          { course_code: code },
          { _id: 1 },
        ).lean();
        if (found?._id) {
          newCourses.push({ ...c, course: found._id });
        } else {
          newCourses.push(c); // fallback; will fail validation if truly missing
        }
      }
      newY.semesters.push({ ...s, courses: newCourses });
    }
    result.push(newY);
  }
  return result;
}

const calculateTotalSemesters = (years) =>
  years.reduce((tot, y) => tot + y.semesters.length, 0);

exports.createPlan = async (req, res) => {
  try {
    const { status } = req.body;
    // 1) Pull studentId from route param
    const studentId = req.params.studentId;
    if (!mongoose.Types.ObjectId.isValid(studentId)) {
      return res.status(400).json({
        success: false,
        message: "Invalid student ID format",
      });
    }

    // 2) Only students can create, and only for themselves
    if (
      req.user.role !== "student" ||
      String(studentId) !== String(req.user.user_id)
    ) {
      return res.status(403).json({
        success: false,
        message: "Only the student can create their own academic plans",
      });
    }

    // 3) Enforce max-3-plans rule
    const planCount = await AcademicPlan.countDocuments({ student: studentId });
    if (planCount >= 2) {
      return res.status(400).json({
        success: false,
        message: "You may only have up to 2 academic plans",
      });
    }

    const { name, years: rawYears, notes } = req.body;

    // 4) Validate input
    if (!name || !name.trim()) {
      return res.status(400).json({
        success: false,
        message: "Plan name is required",
      });
    }

    if (!Array.isArray(rawYears) || rawYears.length === 0) {
      return res
        .status(400)
        .json({ success: false, message: "Years are required" });
    }

    // 5) Compute total years and semesters
    const years = await hydrateCourseRefs(rawYears);
    const semesters = calculateTotalSemesters(years);

    // 6) Create & save
    const newPlan = new AcademicPlan({
      student: studentId,
      name: name.trim(),
      years,
      semesters,
      notes: notes || "",
      // identifier auto-generated by schema
      isDefault: planCount === 0,
      status: status ? status : 1,
    });

    const savedPlan = await newPlan.save();

    return res.status(201).json({
      success: true,
      data: savedPlan,
      message: "Academic plan created successfully",
    });
  } catch (error) {
    console.error("Error creating academic plan:", error);
    return res.status(500).json({
      success: false,
      message: "Internal server error while creating plan",
    });
  }
};

// Get all plans for a user
exports.getUserPlans = async (req, res) => {
  try {
    const studentId = req.params.studentId;

    // Validate the studentId format
    if (!mongoose.Types.ObjectId.isValid(studentId)) {
      return res.status(400).json({
        success: false,
        message: "Invalid student ID format",
      });
    }

    // Security: students can only list their own plans
    if (
      req.user.role === "student" &&
      String(studentId) !== String(req.user.user_id)
    ) {
      return res.status(403).json({
        success: false,
        message: "Forbidden",
      });
    }

    const plans = await AcademicPlan.find({ student: studentId })
      .populate({
        path: "years.semesters.courses.course",
        select:
          "course_code course_name credit_hours prerequisites offered_semester type",
        populate: {
          path: "prerequisites",
          select: "course_code course_name",
        },
      })
      .sort({ isDefault: -1, createdAt: -1 })
      .lean();

    // Always return 200, even if plans.length === 0
    return res.status(200).json({
      success: true,
      data: plans,
      count: plans.length,
    });
  } catch (error) {
    console.error("Error fetching user plans:", error);
    return res.status(500).json({
      success: false,
      message: "Internal server error while fetching plans",
    });
  }
};

// Get a single plan by ID
exports.getPlanById = async (req, res) => {
  try {
    const { planId } = req.params;
    const me = String(req.user.user_id || req.user._id || "");
    const isAdmin = req.user.role === "admin";

    // Students: must own the plan
    // Admins: can read any plan by identifier
    const filter = isAdmin ? { _id: planId } : { _id: planId, student: me };

    const plan = await AcademicPlan.findOne(filter)
      .populate({
        path: "years.semesters.courses.course",
        select:
          "course_code course_name credit_hours prerequisites offered_semester type",
        populate: {
          path: "prerequisites",
          select: "course_code course_name",
        },
      })
      .lean();

    // Return 404 in both "not found" and "not authorized" cases (prevents identifier enumeration)
    if (!plan) {
      return res.status(404).json({
        success: false,
        message: "Academic plan not found",
      });
    }

    return res.status(200).json({
      success: true,
      data: plan,
    });
  } catch (error) {
    console.error("Error fetching plan:", error);
    return res.status(500).json({
      success: false,
      message: "Internal server error while fetching plan",
    });
  }
};

// Update an existing plan
// Update
exports.updatePlan = async (req, res) => {
  try {
    const { name, years: rawYears, notes } = req.body;
    const planId = req.params.planId;
    const studentId = req.user.user_id || req.user._id;

    if (!mongoose.Types.ObjectId.isValid(planId)) {
      return res
        .status(400)
        .json({ success: false, message: "Invalid plan ID format" });
    }

    if (!name || !name.trim()) {
      return res
        .status(400)
        .json({ success: false, message: "Plan name is required" });
    }
    if (!Array.isArray(rawYears) || rawYears.length === 0) {
      return res
        .status(400)
        .json({ success: false, message: "Years are required" });
    }

    const years = await hydrateCourseRefs(rawYears);
    const semesters = years.reduce((tot, y) => tot + y.semesters.length, 0);

    const updatedPlan = await AcademicPlan.findOneAndUpdate(
      { _id: planId, student: studentId },
      {
        name: name.trim(),
        years,
        semesters,
        notes: notes || "",
        updatedAt: new Date(),
      },
      { new: true, runValidators: true },
    ).populate({
      path: "years.semesters.courses.course",
      select:
        "course_code course_name credit_hours prerequisites offered_semester",
      populate: {
        path: "prerequisites",
        select: "course_code course_name",
      },
    });

    if (!updatedPlan) {
      return res
        .status(404)
        .json({ success: false, message: "Academic plan not found" });
    }

    return res.status(200).json({
      success: true,
      data: updatedPlan,
      message: "Academic plan updated successfully",
    });
  } catch (error) {
    console.error("Error updating plan:", error);
    if (error.name === "ValidationError") {
      return res.status(400).json({
        success: false,
        message: "Validation error",
        errors: Object.values(error.errors).map((val) => val.message),
      });
    }
    return res.status(500).json({
      success: false,
      message: "Internal server error while updating plan",
    });
  }
};

// Update only the status of a plan (for Faculty/Admin review)
exports.updatePlanStatus = async (req, res) => {
  try {
    const { planId } = req.params;
    const { status } = req.body;

    // Validate Status input
    if (!status) {
      return res
        .status(400)
        .json({ success: false, message: "Status is required" });
    }

    // Prepare the update object
    let updateFields = {
      status,
      updatedAt: new Date(),
    };

    // If status is 4 (e.g., Approved/Finalized), set this plan as default
    if (status === 4) {
      // 1. Find the plan first to get the student ID
      const targetPlan = await AcademicPlan.findById(planId);
      if (!targetPlan) {
        return res
          .status(404)
          .json({ success: false, message: "Plan not found" });
      }

      await AcademicPlan.deleteMany({
        student: targetPlan.student,
        isDefault: true,
        _id: { $ne: planId },
      });

      // 3. Add isDefault to the current update operation
      updateFields.isDefault = true;
    }

    const updatedPlan = await AcademicPlan.findByIdAndUpdate(
      planId,
      updateFields,
      { new: true, runValidators: true },
    ).populate({
      path: "years.semesters.courses.course",
      select: "course_code course_name credit_hours",
    });

    if (!updatedPlan) {
      return res
        .status(404)
        .json({ success: false, message: "Plan not found" });
    }

    return res.status(200).json({
      success: true,
      data: updatedPlan,
      message: `Plan status updated to ${status}${
        status === 4 ? " and set as current plan" : ""
      }`,
    });
  } catch (error) {
    console.error("Error updating plan status:", error);
    return res
      .status(500)
      .json({ success: false, message: "Internal server error" });
  }
};

// Delete
exports.deletePlan = async (req, res) => {
  try {
    const planId = req.params.planId;
    const studentId = req.user.user_id || req.user._id;

    if (!mongoose.Types.ObjectId.isValid(planId)) {
      return res
        .status(400)
        .json({ success: false, message: "Invalid plan ID format" });
    }

    const plan = await AcademicPlan.findOneAndDelete({
      _id: planId,
      student: studentId,
    });
    if (!plan) {
      return res
        .status(404)
        .json({ success: false, message: "Academic plan not found" });
    }

    if (plan.isDefault) {
      const anotherPlan = await AcademicPlan.findOne({ student: studentId })
        .sort({ createdAt: -1 })
        .limit(1);
      if (anotherPlan) {
        anotherPlan.isDefault = true;
        await anotherPlan.save();
      }
    }

    return res
      .status(200)
      .json({ success: true, message: "Academic plan deleted successfully" });
  } catch (error) {
    console.error("Error deleting plan:", error);
    return res.status(500).json({
      success: false,
      message: "Internal server error while deleting plan",
    });
  }
};

// Set default
exports.setDefaultPlan = async (req, res) => {
  try {
    const planId = req.params.planId;
    const studentId = req.user.user_id || req.user._id;

    if (!mongoose.Types.ObjectId.isValid(planId)) {
      return res
        .status(400)
        .json({ success: false, message: "Invalid plan ID format" });
    }

    const plan = await AcademicPlan.findOne({
      _id: planId,
      student: studentId,
    });
    if (!plan) {
      return res
        .status(404)
        .json({ success: false, message: "Academic plan not found" });
    }

    const session = await mongoose.startSession();
    session.startTransaction();
    try {
      await AcademicPlan.updateMany(
        { student: studentId, _id: { $ne: planId } },
        { $set: { isDefault: false } },
        { session },
      );
      plan.isDefault = true;
      await plan.save({ session });
      await session.commitTransaction();

      return res.status(200).json({
        success: true,
        data: plan,
        message: "Default plan updated successfully",
      });
    } catch (error) {
      await session.abortTransaction();
      throw error;
    } finally {
      session.endSession();
    }
  } catch (error) {
    console.error("Error setting default plan:", error);
    return res.status(500).json({
      success: false,
      message: "Internal server error while setting default plan",
    });
  }
};
